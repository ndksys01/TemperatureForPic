CCS PCM C Compiler, Version 4.140, 9036               09-Jun-14 20:38

               Filename:   C:\Users\Nguyen\Documents\GitHub\TemperatureForPic\NhietDo\NhietDo.lst

               ROM used:   787 words (10%)
                           Largest free fragment is 2048
               RAM used:   29 (8%) at main() level
                           45 (12%) worst case
               Stack:     3 worst case (1 in main + 2 for interrupts)

*
0000:  MOVLW  02
0001:  MOVWF  0A
0002:  GOTO   22A
0003:  NOP
0004:  MOVWF  7F
0005:  SWAPF  03,W
0006:  CLRF   03
0007:  MOVWF  21
0008:  MOVF   0A,W
0009:  MOVWF  20
000A:  CLRF   0A
000B:  MOVF   04,W
000C:  MOVWF  22
000D:  MOVF   77,W
000E:  MOVWF  23
000F:  MOVF   78,W
0010:  MOVWF  24
0011:  MOVF   79,W
0012:  MOVWF  25
0013:  MOVF   7A,W
0014:  MOVWF  26
0015:  BCF    03.7
0016:  BCF    03.5
0017:  MOVLW  8C
0018:  MOVWF  04
0019:  BTFSS  00.5
001A:  GOTO   01D
001B:  BTFSC  0C.5
001C:  GOTO   02E
001D:  MOVF   22,W
001E:  MOVWF  04
001F:  MOVF   23,W
0020:  MOVWF  77
0021:  MOVF   24,W
0022:  MOVWF  78
0023:  MOVF   25,W
0024:  MOVWF  79
0025:  MOVF   26,W
0026:  MOVWF  7A
0027:  MOVF   20,W
0028:  MOVWF  0A
0029:  SWAPF  21,W
002A:  MOVWF  03
002B:  SWAPF  7F,F
002C:  SWAPF  7F,W
002D:  RETFIE
002E:  BCF    0A.3
002F:  BCF    0A.4
0030:  GOTO   046
.................... #include <16f887.h> 
.................... //////// Standard Header file for the PIC16F887 device //////////////// 
.................... #device PIC16F887 
.................... #list 
....................  
.................... #device  adc=10 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
*
0249:  BCF    03.6
024A:  CLRF   28
024B:  CLRF   29
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #use delay(clock =4M) 
*
0031:  MOVLW  47
0032:  MOVWF  04
0033:  BCF    03.7
0034:  MOVF   00,W
0035:  BTFSC  03.2
0036:  GOTO   045
0037:  MOVLW  01
0038:  MOVWF  78
0039:  CLRF   77
003A:  DECFSZ 77,F
003B:  GOTO   03A
003C:  DECFSZ 78,F
003D:  GOTO   039
003E:  MOVLW  4A
003F:  MOVWF  77
0040:  DECFSZ 77,F
0041:  GOTO   040
0042:  GOTO   043
0043:  DECFSZ 00,F
0044:  GOTO   037
0045:  RETURN
.................... #use rs232(baud=9600,xmit=PIN_C6,rcv=PIN_C7) 
....................  
....................    INT temp=0; 
....................  
.................... char nhietDo[4]; 
.................... float tmpNhietdo; 
....................  
.................... void init_adc(INT kenh) 
.................... { 
....................    setup_adc (adc_clock_internal); 
*
0061:  BSF    1F.6
0062:  BSF    1F.7
0063:  BSF    03.5
0064:  BSF    1F.7
0065:  BCF    03.5
0066:  BSF    1F.0
....................  
....................    IF (kenh == 0) 
0067:  MOVF   34,F
0068:  BTFSS  03.2
0069:  GOTO   07E
....................    { 
....................       setup_adc_ports (sAN0|VSS_VDD); 
006A:  BSF    03.5
006B:  BSF    03.6
006C:  MOVF   09,W
006D:  ANDLW  C0
006E:  MOVWF  09
006F:  BCF    03.6
0070:  BCF    1F.4
0071:  BCF    1F.5
0072:  MOVLW  01
0073:  BSF    03.6
0074:  MOVWF  08
....................       set_adc_channel (0); 
0075:  MOVLW  00
0076:  MOVWF  78
0077:  BCF    03.5
0078:  BCF    03.6
0079:  MOVF   1F,W
007A:  ANDLW  C3
007B:  IORWF  78,W
007C:  MOVWF  1F
....................    } 
....................  
....................    else IF (kenh == 1) 
007D:  GOTO   093
007E:  DECFSZ 34,W
007F:  GOTO   093
....................    { 
....................       setup_adc_ports (sAN1|VSS_VDD); 
0080:  BSF    03.5
0081:  BSF    03.6
0082:  MOVF   09,W
0083:  ANDLW  C0
0084:  MOVWF  09
0085:  BCF    03.6
0086:  BCF    1F.4
0087:  BCF    1F.5
0088:  MOVLW  02
0089:  BSF    03.6
008A:  MOVWF  08
....................       set_adc_channel (1); 
008B:  MOVLW  04
008C:  MOVWF  78
008D:  BCF    03.5
008E:  BCF    03.6
008F:  MOVF   1F,W
0090:  ANDLW  C3
0091:  IORWF  78,W
0092:  MOVWF  1F
....................    } 
.................... } 
0093:  BCF    0A.3
0094:  BCF    0A.4
0095:  GOTO   250 (RETURN)
....................  
.................... #INT_rda 
....................  
.................... void uartInterrupt() 
.................... { 
....................       output_d (255); 
*
0046:  BSF    03.5
0047:  CLRF   08
0048:  MOVLW  FF
0049:  BCF    03.5
004A:  MOVWF  08
....................        delay_ms (500); 
004B:  MOVLW  02
004C:  MOVWF  46
004D:  MOVLW  FA
004E:  MOVWF  47
004F:  CALL   031
0050:  DECFSZ 46,F
0051:  GOTO   04D
....................        output_d (0); 
0052:  BSF    03.5
0053:  CLRF   08
0054:  BCF    03.5
0055:  CLRF   08
....................         delay_ms (500); 
0056:  MOVLW  02
0057:  MOVWF  46
0058:  MOVLW  FA
0059:  MOVWF  47
005A:  CALL   031
005B:  DECFSZ 46,F
005C:  GOTO   058
.................... } 
....................  
005D:  BCF    0C.5
005E:  BCF    0A.3
005F:  BCF    0A.4
0060:  GOTO   01D
.................... void main() 
.................... { 
*
022A:  CLRF   04
022B:  BCF    03.7
022C:  MOVLW  1F
022D:  ANDWF  03,F
022E:  BSF    03.5
022F:  BSF    03.6
0230:  BCF    07.3
0231:  MOVLW  19
0232:  BCF    03.6
0233:  MOVWF  19
0234:  MOVLW  A6
0235:  MOVWF  18
0236:  MOVLW  90
0237:  BCF    03.5
0238:  MOVWF  18
0239:  CLRF   2A
023A:  BSF    03.5
023B:  BSF    03.6
023C:  MOVF   09,W
023D:  ANDLW  C0
023E:  MOVWF  09
023F:  BCF    03.6
0240:  BCF    1F.4
0241:  BCF    1F.5
0242:  MOVLW  00
0243:  BSF    03.6
0244:  MOVWF  08
0245:  BCF    03.5
0246:  CLRF   07
0247:  CLRF   08
0248:  CLRF   09
*
024C:  CLRF   33
....................    UNSIGNED char a = 0; 
....................    init_adc (1) ; 
024D:  MOVLW  01
024E:  MOVWF  34
024F:  GOTO   061
....................    //enable_interrupts (global); //Cho phep ngat toan cuc 
....................    //enable_interrupts (INT_rda); //Cho phep ngat UART 
....................    WHILE (1) 
....................    { 
....................        
....................       temp = read_adc (); 
0250:  BSF    1F.1
0251:  BTFSC  1F.1
0252:  GOTO   251
0253:  BSF    03.5
0254:  MOVF   1E,W
0255:  BCF    03.5
0256:  MOVWF  2A
....................       tmpNhietdo = (FLOAT) ( ((temp * 4.0001 * 100) / 1024)); 
0257:  CLRF   35
0258:  MOVF   2A,W
0259:  MOVWF  34
025A:  GOTO   096
025B:  MOVF   7A,W
025C:  MOVWF  3B
025D:  MOVF   79,W
025E:  MOVWF  3A
025F:  MOVF   78,W
0260:  MOVWF  39
0261:  MOVF   77,W
0262:  MOVWF  38
0263:  MOVLW  D2
0264:  MOVWF  3F
0265:  CLRF   3E
0266:  CLRF   3D
0267:  MOVLW  81
0268:  MOVWF  3C
0269:  CALL   0B5
026A:  MOVF   77,W
026B:  MOVWF  34
026C:  MOVF   78,W
026D:  MOVWF  35
026E:  MOVF   79,W
026F:  MOVWF  36
0270:  MOVF   7A,W
0271:  MOVWF  37
0272:  MOVWF  3B
0273:  MOVF   79,W
0274:  MOVWF  3A
0275:  MOVF   78,W
0276:  MOVWF  39
0277:  MOVF   77,W
0278:  MOVWF  38
0279:  CLRF   3F
027A:  CLRF   3E
027B:  MOVLW  48
027C:  MOVWF  3D
027D:  MOVLW  85
027E:  MOVWF  3C
027F:  CALL   0B5
0280:  MOVF   77,W
0281:  MOVWF  34
0282:  MOVF   78,W
0283:  MOVWF  35
0284:  MOVF   79,W
0285:  MOVWF  36
0286:  MOVF   7A,W
0287:  MOVWF  37
0288:  MOVWF  3B
0289:  MOVF   79,W
028A:  MOVWF  3A
028B:  MOVF   78,W
028C:  MOVWF  39
028D:  MOVF   77,W
028E:  MOVWF  38
028F:  CLRF   3F
0290:  CLRF   3E
0291:  CLRF   3D
0292:  MOVLW  89
0293:  MOVWF  3C
0294:  GOTO   12A
0295:  MOVF   7A,W
0296:  MOVWF  32
0297:  MOVF   79,W
0298:  MOVWF  31
0299:  MOVF   78,W
029A:  MOVWF  30
029B:  MOVF   77,W
029C:  MOVWF  2F
....................        nhietDo[0]= '#' ; 
029D:  MOVLW  23
029E:  MOVWF  2B
....................       nhietDo[1]= '1' ; 
029F:  MOVLW  31
02A0:  MOVWF  2C
....................       nhietDo[2] = ( ( (INT) tmpNhietdo) % 100) / 10 + 48; 
02A1:  MOVF   32,W
02A2:  MOVWF  37
02A3:  MOVF   31,W
02A4:  MOVWF  36
02A5:  MOVF   30,W
02A6:  MOVWF  35
02A7:  MOVF   2F,W
02A8:  MOVWF  34
02A9:  CALL   1F6
02AA:  MOVF   78,W
02AB:  MOVWF  35
02AC:  MOVLW  64
02AD:  MOVWF  36
02AE:  CALL   215
02AF:  MOVF   77,W
02B0:  MOVWF  35
02B1:  MOVLW  0A
02B2:  MOVWF  36
02B3:  CALL   215
02B4:  MOVLW  30
02B5:  ADDWF  78,W
02B6:  MOVWF  2D
....................       nhietDo[3] = ( (INT) tmpNhietdo % 100) % 10 + 48; 
02B7:  MOVF   32,W
02B8:  MOVWF  37
02B9:  MOVF   31,W
02BA:  MOVWF  36
02BB:  MOVF   30,W
02BC:  MOVWF  35
02BD:  MOVF   2F,W
02BE:  MOVWF  34
02BF:  CALL   1F6
02C0:  MOVF   78,W
02C1:  MOVWF  35
02C2:  MOVLW  64
02C3:  MOVWF  36
02C4:  CALL   215
02C5:  MOVF   77,W
02C6:  MOVWF  35
02C7:  MOVLW  0A
02C8:  MOVWF  36
02C9:  CALL   215
02CA:  MOVLW  30
02CB:  ADDWF  77,W
02CC:  MOVWF  2E
....................       putc (nhietDo[0]); '#' ; 
02CD:  MOVF   2B,W
02CE:  BTFSS  0C.4
02CF:  GOTO   2CE
02D0:  MOVWF  19
....................       putc (nhietDo[1]); '1' ; 
02D1:  MOVF   2C,W
02D2:  BTFSS  0C.4
02D3:  GOTO   2D2
02D4:  MOVWF  19
....................       putc (nhietDo[2]); delay_ms (1) ; 
02D5:  MOVF   2D,W
02D6:  BTFSS  0C.4
02D7:  GOTO   2D6
02D8:  MOVWF  19
02D9:  CLRF   27
02DA:  BTFSC  0B.7
02DB:  BSF    27.7
02DC:  BCF    0B.7
02DD:  MOVLW  01
02DE:  MOVWF  47
02DF:  CALL   031
02E0:  BTFSC  27.7
02E1:  BSF    0B.7
....................       putc (nhietDo[3]); delay_ms (1) ; 
02E2:  MOVF   2E,W
02E3:  BTFSS  0C.4
02E4:  GOTO   2E3
02E5:  MOVWF  19
02E6:  CLRF   27
02E7:  BTFSC  0B.7
02E8:  BSF    27.7
02E9:  BCF    0B.7
02EA:  MOVLW  01
02EB:  MOVWF  47
02EC:  CALL   031
02ED:  BTFSC  27.7
02EE:  BSF    0B.7
....................       delay_ms (500); delay_ms (500) ; 
02EF:  MOVLW  02
02F0:  MOVWF  34
02F1:  CLRF   27
02F2:  BTFSC  0B.7
02F3:  BSF    27.7
02F4:  BCF    0B.7
02F5:  MOVLW  FA
02F6:  MOVWF  47
02F7:  CALL   031
02F8:  BTFSC  27.7
02F9:  BSF    0B.7
02FA:  DECFSZ 34,F
02FB:  GOTO   2F1
02FC:  MOVLW  02
02FD:  MOVWF  34
02FE:  CLRF   27
02FF:  BTFSC  0B.7
0300:  BSF    27.7
0301:  BCF    0B.7
0302:  MOVLW  FA
0303:  MOVWF  47
0304:  CALL   031
0305:  BTFSC  27.7
0306:  BSF    0B.7
0307:  DECFSZ 34,F
0308:  GOTO   2FE
....................       output_d (a); 
0309:  BSF    03.5
030A:  CLRF   08
030B:  BCF    03.5
030C:  MOVF   33,W
030D:  MOVWF  08
....................       a = 255 - a; 
030E:  MOVF   33,W
030F:  SUBLW  FF
0310:  MOVWF  33
....................  
....................        
....................    } 
0311:  GOTO   250
.................... } 
....................  
....................  
0312:  SLEEP

Configuration Fuses:
   Word  1: 2FE7   RC NOWDT PUT MCLR NOPROTECT NOCPD BROWNOUT IESO FCMEN NOLVP NODEBUG
   Word  2: 3FFF   BORV40 NOWRT
